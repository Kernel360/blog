---
layout: post  
title: "RabbitMQ의 기초 개념"
author: "장정환"
categories: "기술블로그"
banner:
  image: "assets/images/post/2023-11-05.webp"
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
tags: ["Message Queue", "RabbitMQ", "동기", "비동기"]
---
<br/><br/>

## RabbitMQ란?

RabbitMQ는 메시지를 Producer로부터 Consumer에게 전달하는 메시지 브로커입니다.
애플리케이션 간 통신을 비동기적으로 처리할 수 있도록 도와주는 시스템으로서, 다양한 언어와 플랫폼에서 사용할 수 있는 AMQP(Advanced Message Queuing Protocol)를 기본적으로 사용하지만, STOMP, MQTT, HTTP 등을 포함한 다양한 프로토콜을 지원합니다.
<br/><br/>

## 왜 RabbitMQ가 필요할까?

모노리스 시스템에서는 한 컴포넌트가 다른 컴포넌트의 응답을 직접 기다려야 하므로 동기적 결합이 강합니다.
반면, RabbitMQ를 사용하면 메시지를 큐에 적재해 두고 비동기적으로 처리할 수 있으므로, 다음과 같은 이점을 얻을 수 있습니다.

- 비동기 메시지를 사용하여 다른 응용 프로그램 사이에서 데이터 송수신을 할 수 있다.
- 클라이언트에 대한 동기 처리는 병목의 요인이므로 비동기로 처리해도 될 영역에 대해서는 큐를 통해 분리해서 처리한다.
- 분산 환경에서 응용 프로그램들을 분리하고 독립적으로 확장하기 위해서 사용하며, 기능별로 모듈 구성이 용이하다.
- 요청에 대한 응답을 기다릴 필요가 없기 때문에 각 영역의 역할만 신경 쓰면 된다.
- 데이터 유실을 방지하고, 즉시 처리하지 않아도 나중에 다시 처리가 가능하다. 또한, 메시지 영구 저장, 메시지 확인, 장애 복구 메커니즘을 통해 메시지의 신뢰성을 보장한다.
- 여러 노드에 걸쳐 쉽게 확장할 수 있어 높은 가용성을 제공한다.
- 다양한 Exchange 유형과 라우팅 규칙을 지원하여 메시지를 효과적으로 라우팅하고 관리할 수 있다.
<br/><br/>

## RabbitMQ의 핵심 구성 요소

RabbitMQ는 단순히 큐에 메시지를 넣고 빼는 시스템이 아닙니다. Exchange, Binding, Queue를 이용해 메시지가 정확한 위치로 라우팅이 되도록 도와줍니다.

### Queue

일반적으로 알고 있는 큐입니다. 메모리나 디스크에 메시지를 저장하고, 그것을 Consumer에게 전달하는 역할을 합니다.

### Exchange

Producer로부터 수신한 메시지를 적절한 큐 또는 다른 Exchange로 분배하는 라우터의 기능을 합니다. Exchange 타입에 따라 메시지 라우팅 방식이 달라집니다. 

<Exchange 유형>
- Direct: 특정 라우팅 키와 정확히 일치하는 큐에 메시지를 전송
- Fanout: 모든 큐에 메시지를 브로드캐스트
- Topic: 라우팅 키 패턴을 기반으로 메시지를 특정 큐에 전달
- Headers: 메시지 헤더 속성에 따라 메시지를 라우팅

### Binding

Exchange와 Queue 사이의 연결 관계를 정의합니다. 라우팅 키를 기준으로 특정 메시지가 어떤 큐로 전달될지 결정하며, 하나의 큐는 여러 Exchange와 바인딩될 수 있습니다.
<br/><br/>

## RabbitMQ의 장단점

RabbitMQ의 장점과 단점으로는 다음과 같은 것들이 있습니다.

<장점>
- 비동기 처리: 백그라운드 작업이나 대기 시간이 긴 작업에 적합
- 확장성: 큐를 기준으로 수평 확장이 쉬움
- 내결함성: Consumer 중 하나가 실패하더라도 다른 Consumer가 작업을 이어받아 처리할 수 있어, 시스템이 중단 없이 작동
- 언어 및 플랫폼 독립성: 다양한 클라이언트 라이브러리 지원
- 모니터링 UI 제공: 관리가 쉬움

<단점>
- 운영 복잡성: 클러스터 구성이나 퍼시스턴스 설정이 복잡할 수 있음
- 메시지 처리 지연: 잘못된 라우팅 설정이나 소비자 병목으로 처리 지연 발생 가능
- 학습 곡선: Exchange/Binding 등 개념이 익숙하지 않으면 사용 초기엔 혼란스러울 수 있음
- 과도한 의존: 모든 통신을 메시지화하면 디버깅이 어려워질 수 있음
<br/><br/>

## 언제 RabbitMQ를 사용하면 좋을까?

- 이메일 발송, 알림 전송처럼 지연이 허용되는 작업
- 트래픽이 폭증할 수 있는 시스템(ex. 주문 처리, 실시간 로그 처리)
- 마이크로서비스 간 메시지 기반 통신이 필요한 경우
- 생산자-소비자 속도가 불균형한 경우 (생산이 빠르고 소비가 느릴 때)
<br/><br/>

## 마치며

RabbitMQ는 다양한 메시징 패턴을 지원하고 시스템 간 결합도를 낮춰 주는 중간 계층의 핵심 컴포넌트로 자리 잡고 있습니다.
하지만 모든 상황에 RabbitMQ가 정답은 아닙니다. 처리 지연이 민감하거나 실시간 응답이 중요한 경우, 또는 메시지 브로커를 별도로 운영하기 어려운 환경이라면 Kafka, Redis Stream 등의 대안도 고려해볼 수 있습니다. RabbitMQ뿐 아니라 다양한 것을 시도하고 튜닝해 보면서 최적의 성능을 내는 것이 중요합니다.
