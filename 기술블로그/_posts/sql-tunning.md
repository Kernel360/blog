---
layout: post  
title: "인덱스의 기본과 튜닝"  
author: "전상호"  
categories: "기술블로그"  
banner:  
  background: "#2a9d8f"  
  height: "100vh"  
  min_height: "38vh"  
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"  
  tags: ["SQL", "INDEX", "TUNNING"]
---

# 1. 인덱스 구조 및 탐색

## 1.1 데이터 검색 방식

1. **Table Full Scan** - 전체 테이블을 순차적으로 검색 (대량 데이터 검색 시 사용)

2. **Index Range Scan** - 인덱스를 활용한 이진 탐색 (소규모 데이터 검색 시 효과적)

## 1.2 인덱스 튜닝의 핵심 요소

- 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용.
1. **인덱스 스캔 효율화** – 인덱스 스캔 과정에서 발생하는 비효율을 줄이기
2. **랜덤 액세스 최소화** – 테이블 액세스 횟수 줄이기

### 1.2 인덱스 구조

- **B-Tree (Balanced Tree)** 구조 사용

Balanced: 루트 노드에서 리프 노드까지의 깊이 차이가 2 이상 나지 않음.

### 1.2.1 인덱스 탐색 과정

- **수직적 탐색**: 인덱스 스캔 시작점을 찾는 과정
- **수평적 탐색**: 데이터를 찾는 과정

## 1.3 결합 인덱스와 컬럼 배치

결합 인덱스를 생성할 때 컬럼 배치 순서는 스캔 횟수에 영향을 주지 않음.

```sql
SELECT 이름, 성별
FROM 사원
WHERE 성별 = '여자'
AND 이름 = '유관순'
```

- 인덱스를 `[성별 + 이름]` 순으로 구성한 경우
- 인덱스를 `[이름 + 성별]` 순으로 구성한 경우

차이가 없음.

# 2. 인덱스 기본 사용법

## 2.1 인덱스를 Range Scan 할 수 없는 경우

- 변형된 조건으로 인해 인덱스 사용 불가:
    - `substr()`
    - `nvl()`
    - `like '김%'`는 인덱스 사용 가능하지만 `%김`은 불가능
    - `IN` 연산자 – `OR` 조건을 표현하는 방식으로, 인덱스 사용 불가
```
-- 인덱스 Range Scan 불가 예시
WHERE 전화번호 = :tel_no OR 고객명 = :cust_nm
```

## 2.2 인덱스를 활용한 정렬 최적화

- 인덱스를 활용하면 ORDER BY 시 추가적인 정렬 연산을 생략할 수 있음.
- 단, ORDER BY에 가공된 컬럼이 있으면 인덱스를 사용할 수 없음.

## 2.3 인덱스 확장 기능 사용법

주요 인덱스 스캔 방식

1. Index Range Scan - 일반적인 인덱스 탐색

2. Index Full Scan - 인덱스 전체 탐색 (결과 순서 보장)

3. Index Unique Scan - 유니크 인덱스 검색

4. Index Skip Scan - 인덱스 일부만 검색

5. Index Fast Full Scan - 디스크에 저장된 순서대로 인덱스 리프 블록 탐색 (순서 보장 X, 병렬 스캔 가능)

# 3장. 인덱스 튜닝

## 3.1 테이블 액세스 최소화

### ROWID 개념

- 테이블 내 특정 행의 물리적 주소를 나타내는 값.

### 클러스터링 팩터 (Clustering Factor, CF)

- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 인접한 정도.

- CF가 낮을수록 인덱스 검색 효율이 좋음.

## 3.1.1 인덱스 컬럼 추가

테이블 랜덤 액세스를 줄이기 위해 컬럼을 추가하는 기법.

수직 탐색 비용은 동일하지만 테이블 접근 횟수를 줄일 수 있음.

## 3.1.2 인덱스 구조 테이블

Index-Organized Table (IOT): 테이블 데이터를 인덱스 구조로 저장하여 랜덤 액세스를 줄이는 방식.

## 3.2 부분범위 처리 활용

부분범위 처리란?

- 결과를 일정량씩 나누어 전송하는 방식으로, 불필요한 대량 연산을 피함.
  
- ORDER BY 없이 인덱스를 활용하면 정렬 연산 생략 가능.

## 3.3 인덱스 스캔 효율화

### 인덱스 탐색 조건

조건절이 많을수록 검색 범위가 좁아짐

= → <, > → BETWEEN 순으로 느려짐

선행 컬럼 선택이 중요

### 인덱스 필터 조건

액세스 조건: 인덱스 스캔 범위를 결정하는 조건

필터 조건: 테이블 접근 여부를 결정하는 조건

## 3.4 인덱스 설계

### 인덱스 설계가 어려운 이유

인덱스 개수가 많으면 DML 성능 저하, 저장 공간 증가, 운영 비용 상승 문제 발생.

인덱스 추가는 부하 발생, 변경은 운영 리스크 증가 → 최적 설계가 중요.

### 인덱스 설계의 두 가지 핵심 기준

조건절에서 항상 사용되거나 자주 조회되는 컬럼을 포함할 것

= 조건이 자주 사용되는 컬럼을 인덱스 앞쪽에 배치할 것

### 중복 인덱스 제거

불필요한 중복 인덱스는 삭제하여 시스템 부하를 줄여야 함.
```
-- 중복 인덱스 제거 예시
X01: 계약ID + 청약일자
X02: 계약ID + 청약일자 + 보험개시일자
X03: 계약ID + 청약일자 + 보험개시일자 + 보험종료일자

-- X03이 모든 정보를 포함하므로 X01, X02 삭제 가능
```
# 결론

인덱스 튜닝은 단순히 속도를 높이는 것이 아니라, 전체 시스템의 부하를 줄이고 최적화하는 과정이다.

조건절과 인덱스 설계를 잘 조합하여 성능을 최적화하는 것이 핵심.
