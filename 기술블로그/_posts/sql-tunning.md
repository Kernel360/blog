---
layout: post  
title: "인덱스의 기본과 튜닝"  
author: "전상호"  
categories: "기술블로그"  
banner:  
  background: "#2a9d8f"  
  height: "100vh"  
  min_height: "38vh"  
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"  
  tags: ["SQL", "INDEX", "TUNNING"]
---

# 1. 인덱스 구조 및 탐색

## 1.1 데이터 검색 방식

1. **Table Full Scan** - 전체 테이블을 순차적으로 검색 (대량 데이터 검색 시 사용)

2. **Index Range Scan** - 인덱스를 활용한 이진 탐색 (소규모 데이터 검색 시 효과적)

## 1.2 인덱스 튜닝의 핵심 요소

- 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용.
1. **인덱스 스캔 효율화** – 인덱스 스캔 과정에서 발생하는 비효율을 줄이기
2. **랜덤 액세스 최소화** – 테이블 액세스 횟수 줄이기

### 1.2 인덱스 구조

- **B-Tree (Balanced Tree)** 구조 사용

Balanced: 루트 노드에서 리프 노드까지의 깊이 차이가 2 이상 나지 않음.

### 1.2.1 인덱스 탐색 과정

- **수직적 탐색**: 인덱스 스캔 시작점을 찾는 과정
- **수평적 탐색**: 데이터를 찾는 과정

## 1.3 결합 인덱스와 컬럼 배치

결합 인덱스를 생성할 때 컬럼 배치 순서는 스캔 횟수에 영향을 주지 않음.

```sql
SELECT 이름, 성별
FROM 사원
WHERE 성별 = '여자'
AND 이름 = '유관순'
```

- 인덱스를 `[성별 + 이름]` 순으로 구성한 경우
- 인덱스를 `[이름 + 성별]` 순으로 구성한 경우

차이가 없음.

### 컬럼 배치 순서에 따라 스캔 횟수가 달라지는 경우
선행 컬럼을 활용한 범위 검색이 있는 경우

```sql
SELECT *
FROM 사원
WHERE 성별 = '여자'
AND 이름 LIKE '유%'
```

✔ [성별 + 이름] 인덱스를 사용할 경우
	- 성별 = '여자'로 먼저 범위를 좁힌 후
	- 이름 LIKE '유%' 를 인덱스에서 연속적인 범위 검색 가능
	- 효율적인 인덱스 스캔 가능

✔ [이름 + 성별] 인덱스를 사용할 경우
	- 이름 LIKE '유%' 가 먼저 적용되지만
	- 성별 = '여자' 가 후행 컬럼 이므로 인덱스 필터링이 덜 효과적
	- 불필요한 인덱스 스캔 증가 가능

➡ 선행 컬럼이 범위 검색(IN, BETWEEN, LIKE ‘값%’)을 포함할 때 인덱스 컬럼 배치가 중요합니다.

# 2. 인덱스 기본 사용법

## 2.1 인덱스 생성 방법

### 기본 B-Tree 인덱스 생성
```sql
CREATE INDEX idx_사원_이름 ON 사원(이름);
```
- 사원 테이블의 이름 컬럼에 대한 인덱스를 생성✔ 검색 시 WHERE 이름 = '유관순' 같은 조건이 있을 때 사용됨

### 결합 인덱스(Composite Index) 생성
```sql
CREATE INDEX idx_사원_성별_이름 ON 사원(성별, 이름);
```
- (성별, 이름) 순서로 결합 인덱스 생성✔ WHERE 성별 = '여자' AND 이름 = '유관순' 같은 조건에서 최적화

### 고유 인덱스(Unique Index) 생성
```sql
CREATE UNIQUE INDEX idx_사원_주민번호 ON 사원(주민번호);
```
- 중복을 허용하지 않는 인덱스✔ PRIMARY KEY 나 UNIQUE 제약조건과 같은 역할 수행

### 비트맵 인덱스(Bitmap Index, 주로 OLAP 환경)
```sql
CREATE BITMAP INDEX idx_사원_성별 ON 사원(성별);
```
- 성별 같은 값이 적은 컬럼(카디널리티 낮음)에 적합✔ 읽기 성능 최적화, 하지만 업데이트 빈번한 환경에서는 부적합

## 2.2 인덱스 사용 여부 확인

### EXPLAIN 으로 인덱스가 사용되는지 체크
```sql
EXPLAIN SELECT * FROM 사원 WHERE 이름 = '유관순';
```
- 실행 계획을 확인하여 idx_사원_이름 인덱스가 사용되는지 확인✔ type: index 또는 type: range 가 나오면 인덱스 활용됨

### EXPLAIN ANALYZE 사용 (MySQL 8 이상)
```sql
EXPLAIN ANALYZE SELECT * FROM 사원 WHERE 성별 = '여자' AND 이름 = '유관순';
```
- 실제 실행한 후 쿼리 비용(cost)과 실행 시간 확인✔ 인덱스 적용 여부와 성능 개선 가능성 분석

### SHOW INDEX FROM 테이블명 으로 테이블의 인덱스 목록 확인
```sql
SHOW INDEX FROM 사원;
```
- 현재 테이블에 어떤 인덱스가 생성되어 있는지 확인 가능✔ Key_name, Column_name, Cardinality 등의 정보를 확인하여 활용 가능성 분석

## 2.3 인덱스 삭제 및 관리

### 인덱스 삭제
```sql
DROP INDEX idx_사원_이름 ON 사원;
```
- 필요 없는 인덱스는 삭제하여 쓰기 성능 향상

### 테이블 통계 갱신 (MySQL, PostgreSQL 등)
```sql
ANALYZE TABLE 사원;
```
- DB 엔진이 인덱스 최적화된 실행 계획을 세울 수 있도록 도와줌✔ 대량 데이터 변경 후 실행하면 효과적

## 2.4 인덱스를 Range Scan 할 수 없는 경우

- 변형된 조건으로 인해 인덱스 사용 불가:
    - `substr()`
    - `nvl()`
    - `like '김%'`는 인덱스 사용 가능하지만 `%김`은 불가능
    - `IN` 연산자 – `OR` 조건을 표현하는 방식으로, 인덱스 사용 불가
```
-- 인덱스 Range Scan 불가 예시
WHERE 전화번호 = :tel_no OR 고객명 = :cust_nm
```

## 2.5 인덱스를 활용한 정렬 최적화

- 인덱스를 활용하면 ORDER BY 시 추가적인 정렬 연산을 생략할 수 있음.
- 단, ORDER BY에 가공된 컬럼이 있으면 인덱스를 사용할 수 없음.

### ORDER BY + LIMIT 최적화

ORDER BY와 LIMIT을 사용할 때 filesort가 발생할 가능성이 높음.

이를 방지하려면 PK(id) > 0 조건을 추가하여 인덱스를 활용할 수 있음.
```sql
SELECT * FROM 사원 WHERE id > 0 ORDER BY 이름 LIMIT 10;
```
- id > 0 조건을 추가하면 인덱스를 활용한 정렬 최적화 가능✔ 불필요한 filesort 연산을 줄여 성능 개선

## 2.6 인덱스 확장 기능 사용법

주요 인덱스 스캔 방식

1. Index Range Scan - 일반적인 인덱스 탐색

2. Index Full Scan - 인덱스 전체 탐색 (결과 순서 보장)

3. Index Unique Scan - 유니크 인덱스 검색

4. Index Skip Scan - 인덱스 일부만 검색

5. Index Fast Full Scan - 디스크에 저장된 순서대로 인덱스 리프 블록 탐색 (순서 보장 X, 병렬 스캔 가능)

# 3장. 인덱스 튜닝

## 3.1 테이블 액세스 최소화

### ROWID 개념

- 테이블 내 특정 행의 물리적 주소를 나타내는 값.

### 클러스터링 팩터 (Clustering Factor, CF)

- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 인접한 정도.

- CF가 낮을수록 인덱스 검색 효율이 좋음.

## 3.1.1 인덱스 컬럼 추가

테이블 랜덤 액세스를 줄이기 위해 컬럼을 추가하는 기법.

수직 탐색 비용은 동일하지만 테이블 접근 횟수를 줄일 수 있음.

## 3.1.2 인덱스 구조 테이블

Index-Organized Table (IOT): 테이블 데이터를 인덱스 구조로 저장하여 랜덤 액세스를 줄이는 방식.

## 3.2 부분범위 처리 활용

부분범위 처리란?

- 결과를 일정량씩 나누어 전송하는 방식으로, 불필요한 대량 연산을 피함.
  
- ORDER BY 없이 인덱스를 활용하면 정렬 연산 생략 가능.

## 3.3 인덱스 스캔 효율화

### 인덱스 탐색 조건

조건절이 많을수록 검색 범위가 좁아짐

= → <, > → BETWEEN 순으로 느려짐

선행 컬럼 선택이 중요

### 인덱스 필터 조건

액세스 조건: 인덱스 스캔 범위를 결정하는 조건

필터 조건: 테이블 접근 여부를 결정하는 조건

## 3.4 인덱스 설계

### 인덱스 설계가 어려운 이유

인덱스 개수가 많으면 DML 성능 저하, 저장 공간 증가, 운영 비용 상승 문제 발생.

인덱스 추가는 부하 발생, 변경은 운영 리스크 증가 → 최적 설계가 중요.

### 인덱스 설계의 두 가지 핵심 기준

조건절에서 항상 사용되거나 자주 조회되는 컬럼을 포함할 것

= 조건이 자주 사용되는 컬럼을 인덱스 앞쪽에 배치할 것

### 중복 인덱스 제거

불필요한 중복 인덱스는 삭제하여 시스템 부하를 줄여야 함.
```
-- 중복 인덱스 제거 예시
X01: 계약ID + 청약일자
X02: 계약ID + 청약일자 + 보험개시일자
X03: 계약ID + 청약일자 + 보험개시일자 + 보험종료일자

-- X03이 모든 정보를 포함하므로 X01, X02 삭제 가능
```
# 결론

인덱스 튜닝은 단순히 속도를 높이는 것이 아니라, 전체 시스템의 부하를 줄이고 최적화하는 과정이다.

조건절과 인덱스 설계를 잘 조합하여 성능을 최적화하는 것이 핵심.
