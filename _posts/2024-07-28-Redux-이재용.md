---
layout: post
title: "Redux 훑어보기"
author: "이재용"
categories: "프론트엔드 기술블로그"
banner:
  image: "https://velog.velcdn.com/images/jjh099/post/3fa558f9-2050-402b-aee7-350c02fc6ef2/image.jpeg"
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
tags: ["redux", "리덕스", "입문"]
---
# 리덕스의 탄생

리덕스를 쉽게 이해하고 잘 사용하기 위해 Redux가 등장한 배경부터 살펴봅시다.  
Redux 이전의 상황은 어땠을까요?

### 1) 상태 전달이 복잡했습니다.

App의 규모가 커지면서 여러 컴포넌트가 서로 다른 상태를 관리하게 되었습니다.

쇼핑 카트 애플리케이션을 예로 들면,  
여러 컴포넌트에서 장바구니 상태가 필요할 때, 각 컴포넌트에 상태를 전달하는 과정이 복잡해졌습니다.

장바구니 목록을 보여주는 컴포넌트,  
총 가격을 계산하는 컴포넌트,  
결제를 처리하는 컴포넌트 등 여러 컴포넌트가 장바구니 상태에 접근해야 합니다.

부모 컴포넌트가 상태를 관리하고, 자식 컴포넌트에 props로 전달해야 하는데,  
이렇게 되면 트리 구조가 깊어질수록 상태 전달이 매우 복잡해집니다.

리덕스는 컴포넌트끼리 상태를 전달하지 않고, Store라는 공간에서 상태를 직접 가져옵니다. 

### 2) 상태 동기화가 어려웠습니다.

같은 상태가 여러 컴포넌트에 분산되어 있을 때, 상태를 일관되게 유지하기 어려웠습니다.  
어떤 컴포넌트에서 상태를 변경하면, 다른 컴포넌트에서도 그것을 반영해야 했죠.

사용자가 장바구니에 아이템을 추가하면, 장바구니 목록과 총 가격을 보여주는 컴포넌트가 모두 업데이트되어야 합니다.  
상태를 여러 컴포넌트에 분산시켜 관리하면, 이러한 업데이트를 일관되게 유지하기 어려워집니다.

리덕스는 모든 상태를 하나의 중앙 저장소(Store) 에서 관리합니다. 이를 통해 여러 컴포넌트가 같은 상태를 참조하게 됩니다.

### 3) 디버깅이 어려웠습니다.

여러 컴포넌트에서 상태 변경이 일어나면, 어떤 컴포넌트에서 문제가 발생했는지 추적이 어려웠습니다.  
상태 변경의 흐름을 추적하고 디버깅하는 데 많은 시간이 소요되었죠.

장바구니에 상품을 추가했을 때, 장바구니 목록과 총 가격이 업데이트되지 않는 상황이 발생했다고 가정해봅시다.  
이 경우, 어떤 컴포넌트가 잘못되었는지 추적하기 어렵습니다. 여러 컴포넌트에서 상태를 변경하고 있기 때문입니다.  
해당 상태와 관련 있는 컴포넌트를 하나 하나 추적했어야 했죠.

리덕스는 상태 변경의 흐름을 쉽게 추적할 수 있습니다.  
바로 단방향 데이터 흐름이라는 특성을 가지기 때문인데요.  
이것은 Redux가 Flux 아키텍쳐를 구현한 라이브러리기 때문입니다.

**Flux 아키텍쳐**  
Meta(구 Facebook)에서 만든 구조로, 단방향 데이터 흐름을 사용해 데이터가 어떻게 흐르는지 명확히 하는 코드 패턴입니다.  
Action, Dispatcher, Store, View로 구성되어 있습니다.  
지금은 이정도만 기억해두고, 이후 Redux의 구성 요소에서 자세히 알아봅시다.

---

# Redux의 3가지 원칙

앞서 살펴봤던 과거의 여러 불편함을 개선하기 위해,  
Redux에서는 다음과 같은 3가지 원칙을 지키도록 설계되었습니다.

### 1. 단일 스토어 (Single Source of Truth)

모든 상태가 중앙에서 관리되기 때문에 컴포넌트끼리 상태를 전달할 필요가 없습니다.  
모든 상태가 하나의 store에 있기 때문에, 상태를 일관적으로 유지할 수 있습니다.

### 2. 읽기 전용 상태 (State is Read-Only)

모든 상태는 읽기 전용입니다. 직접 변경이 불가하죠.  
그럼 어떻게 변경할까요?  
'상태를 A로 변경하겠다'라는 정보를 가진 객체(Action)를,  
상태를 변경하는 함수(Reducer)에게 전달해야 합니다. 

복잡하죠?  
하지만 이 덕분에 상태 변경의 흐름을 예측할 수 있습니다.  
모든 상태 변경은 Action을 통해 이루어지기 때문에,  
어떤 Action이 언제 전달되었고, 그 결과로 상태가 어떻게 바뀌었는지 쉽게 알 수 있죠.

### 3. 순수 함수 리듀서 (Changes are Made with Pure Functions)

앞서 말한 상태를 변경하는 함수를 Reducer라고 합니다.  
이 함수는 Action과 이전 상태를 받아서, 새로운 상태를 반환하죠.

그렇다면 순수 함수란 무엇일까요?  
순수 함수란 동일한 입력이 주어지면 항상 동일한 출력을 반환하는 함수를 말합니다.

리듀서는 순수 함수이기 때문에, 동일한 입력이 주어지면 항상 동일한 출력(상태)를 반환합니다.  
그래서 상태 변경을 쉽게 예측할 수 있죠.

---

# 리덕스의 구성

Redux에서 사용되는 개념에 대해 간단히 알아봅시다. 

### 1) 액션 Action

상태 변경을 설명하는 단순한 객체입니다. 

### 2) 액션 생성 함수 Action Creator

Action 객체를 생성하는 함수입니다.  
Action 생성과 dispatch를 위해 사용됩니다.

### 3) 리듀서 Reducer

Action을 받아 새로운 상태를 반환하는 순수 함수입니다.  
이전 상태와 Action을 받아 새로운 상태를 반환합니다.

### 4) 스토어 Store

상태를 저장하고 관리하는 객체입니다.  
스토어는 상태를 읽고(getState), 액션을 디스패치하고(dispatch),  
상태 변경을 구독하는(subscribe) 함수를 제공합니다.

### 5) 디스패치 dispatch

스토어의 내장 함수 중 하나입니다.  
`dispatch(action)` 형태로 액션 객체를 매개변수로 넣어 호출합니다.  
이 함수가 호출되면 스토어는 리듀서 함수를 실행시켜서 새로운 상태를 만들어 줍니다.

### 6) 구독 subscribe

스토어의 내장 함수 중 하나입니다.  
`subscribe` 함수 안에 리스너 함수를 매개변수로 넣어 호출하면,  
상태가 업데이트 될 때마다 이 리스너 함수가 호출됩니다.

---

# 데이터 흐름

1. **액션 생성**: 사용자가 어떤 행동을 하면 액션 생성 함수가 액션 객체를 생성합니다.  
2. **액션 디스패치**: 생성된 액션 객체가 스토어에 디스패치됩니다.  
3. **리듀서 처리**: 액션이 리듀서로 전달되어 새로운 상태를 계산합니다.  
4. **스토어 업데이트**: 스토어가 새로운 상태로 업데이트됩니다.  
5. **구독 및 UI 업데이트**: 상태 변경을 구독하는 컴포넌트들이 새로운 상태를 반영하여 UI를 업데이트합니다.

---

# 어떤 경우에 Redux를 사용하는가?

지금까지 Redux에 대해 간단히 알아보았습니다.  
상태를 변경하기 위한 과정이 상당히 복잡하고, 새롭게 이해해야 할 개념들도 많았죠.

하지만 Redux가 등장한 배경에서 알 수 있듯이, 리덕스는 분명 개발자들의 필요에 의해 만들어졌습니다.  
언제 사용해야 할까요? Redux를 반드시 사용해야만 할까요?

Application의 상태가 단순하고, 컴포넌트 간 상태 공유가 거의 없는 경우에는  
redux보다 `useState`나 `useContext` 훅을 사용해 상태를 관리하는 것이 더 간단하고 적절할 것입니다.

다만 상태가 복잡하고, 하나의 상태를 여러 컴포넌트에서 접근하거나  
상태들을 한 곳에서 관리하고 싶을 때는 Redux 사용을 고려하는 것이 좋겠습니다.

---
